<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>モデル解説（DGP / 3-fac / 1-fac / BPS）</title>
  <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
  <script id="MathJax-script" async
    src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js">
  </script>
  <style>
    body{font-family:system-ui,-apple-system,Segoe UI,Roboto,"Hiragino Kaku Gothic ProN","Noto Sans JP",sans-serif;
         line-height:1.6;margin:24px;color:#111}
    h1{font-size:1.35rem;margin-bottom:8px}
    h2{font-size:1.05rem;margin-top:20px;margin-bottom:6px}
    p{margin:6px 0}
    .eq{background:#f8f8f8;border-left:4px solid #ddd;padding:8px 12px;border-radius:4px}
    .small{font-size:0.9rem;color:#444}
  </style>
</head>
<body>
  <h1>スクリプト内モデルの数式まとめ</h1>

  <h2>1. DGP（データ生成過程）</h2>
  <p class="small">状態 \(S_t\in\{1,2\}\) によって観測モデルが変わる。</p>
  <div class="eq">
    状態1（3因子）：<br/>
    \(\eta_t^{(1)} = B^{(1)} \eta_{t-1}^{(1)} + q_t^{(1)},\quad q_t^{(1)}\sim\mathcal{N}(0,Q^{(1)})\)<br/>
    \(y_t = \Lambda^{(1)}\eta_t^{(1)} + r_t,\quad r_t\sim\mathcal{N}(0,R)\)
  </div>
  <div class="eq">
    状態2（1因子）：<br/>
    \(\eta_t^{(2)} = B^{(2)} \eta_{t-1}^{(2)} + q_t^{(2)},\quad q_t^{(2)}\sim\mathcal{N}(0,Q^{(2)})\)<br/>
    \(y_t = \Lambda^{(2)}\eta_t^{(2)} + r_t,\quad r_t\sim\mathcal{N}(0,R)\)
  </div>
  <div class="eq">
    1→2の遷移確率（シグモイド）：<br/>
    \(P(S_t=2\mid S_{t-1}=1,\eta_{t-1}^{(1)})=\sigma(\gamma_0+\gamma_{\text{task}}\eta_{t-1,1}+\gamma_{\text{goal}}\eta_{t-1,2}+\gamma_{\text{bond}}\eta_{t-1,3})\)
  </div>

  <h2>2. 3-fac（3因子モデルの推定）</h2>
  <p class="small">状態空間形式で因子を3次元で表現。カルマンフィルタで尤度を計算し，最適化でパラメータを推定。</p>
  <div class="eq">
    \(\eta_t = b_0 + B\eta_{t-1} + q_t,\quad q_t\sim\mathcal{N}(0,Q),\quad \eta_t\in\mathbb{R}^3\) <br/>
    \(y_t = \Lambda\eta_t + r_t,\quad r_t\sim\mathcal{N}(0,R)\)
  </div>

  <h2>3. 1-fac（1因子モデルの推定）</h2>
  <p class="small">同様に単一因子で近似。カルマンフィルタで尤度を計算してパラメータ推定。</p>
  <div class="eq">
    \(\eta_t = b_0 + B\eta_{t-1} + q_t,\quad q_t\sim\mathcal{N}(0,Q),\quad \eta_t\in\mathbb{R}^1\) <br/>
    \(y_t = \Lambda\eta_t + r_t,\quad r_t\sim\mathcal{N}(0,R)\)
  </div>

  <h2>4. BPS（Bayesian Predictive Synthesis）— ランダムウォーク重み</h2>
  <p class="small">モデル予測を時変重みで合成し観測を説明するベイズモデル。変分推論で推定。</p>
  <div class="eq">
    \(\logit(w_t)\sim\mathcal{N}(\logit(w_{t-1}),V)\) （重みのランダムウォーク）<br/>
    \(w_t=\mathrm{softmax}(\logit(w_t))\)（確率化）<br/>
    \(\alpha_t\sim\mathcal{N}(\alpha_{t-1},\tau^2 I)\)（時変バイアス）<br/>
    観測モデル：\(\;y_{i,t}\sim\mathcal{N}\big(\sum_{j=1}^J w_{j,t}\,\hat y_{i,t}^{(j)}+\alpha_t,\ \Sigma\big)\)
  </div>

  <h2>補足：カルマンフィルタは「直接のパラメータ更新器」ではない、とは</h2>
  <p class="small">要点：</p>
  <ul>
    <li>カルマンフィルタは与えられたパラメータ \(\theta=(b_0,B,\Lambda,Q,R)\) の下で潜在状態 \(\eta_t\) を逐次推定し、同時に観測尤度 \(p(Y\mid\theta)\) を効率よく計算する道具です。</li>
    <li>このスクリプトでは <code>kalman_filter_torch_loss</code> がカルマンフィルタで対数尤度を返し、その負値を <code>loss</code> として最適化（AdamW）しています。</li>
    <li>つまり：</li>
  </ul>
  <div class="eq">
    カルマンフィルタ：状態推定と尤度計算を担当。<br/>
    パラメータ推定：尤度を最大化するよう外側で最適化（ここでは勾配法）により行う。
  </div>

  <h2>結論（短く）</h2>
  <p>・3-fac / 1-fac はカルマンフィルタを用いて <strong>尤度を計算</strong> し、その尤度を最適化することでパラメータを推定しています。<br/>
     ・BPS はカルマンで得た各モデルの予測を入力に取り、時変の確率的重みで合成し、変分推論（SVI）で学習します。</p>

  <p class="small">必要ならこのHTMLを少し改良して、図（モデル構造や重み推移プロット）を埋め込みます。どうしますか？</p>
</body>
</html>
